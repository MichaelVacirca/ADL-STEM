# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "E:/Users/Hasan/Development/MarmaladeProjects/ADL-STEM/libraries/box2d/build_box2d_vc10/temp_defines_release.h" 1
# 1 "<command-line>" 2
# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.cpp"
# 19 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.cpp"
# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.h" 1
# 22 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.h"
# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2Shape.h" 1
# 22 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2Shape.h"
# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2BlockAllocator.h" 1
# 22 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2BlockAllocator.h"
# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Settings.h" 1
# 22 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Settings.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/cassert" 1
# 18 "c:/marmalade/6.0/s3e/h/std/c++/cassert"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h" 1
# 62 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl_user_config.h" 1
# 63 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h" 2




# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h" 2


# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "c:/marmalade/6.0/s3e/h/std/c++/config/stlcomp.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "c:/marmalade/6.0/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "c:/marmalade/6.0/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h" 2
# 83 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h" 2
# 488 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 2
# 19 "c:/marmalade/6.0/s3e/h/std/c++/cassert" 2





# 1 "c:/marmalade/6.0/s3e/h/std/assert.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/assert.h"
# 1 "c:/marmalade/6.0/s3e/h/std/sys/types.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/sys/types.h"
# 1 "c:/marmalade/6.0/s3e/h/s3eTypes.h" 1
# 37 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 51 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 74 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 96 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 108 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;







typedef int64_t int64;
typedef uint64_t uint64;





typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 226 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 244 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 256 "c:/marmalade/6.0/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "c:/marmalade/6.0/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/stddef.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 17 "c:/marmalade/6.0/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/stdint.h" 1
# 19 "c:/marmalade/6.0/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "c:/marmalade/6.0/s3e/h/std/sys/types.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/sys/select.h" 1
# 24 "c:/marmalade/6.0/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "c:/marmalade/6.0/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "c:/marmalade/6.0/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
    typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "c:/marmalade/6.0/s3e/h/std/assert.h" 2

extern "C" {
# 43 "c:/marmalade/6.0/s3e/h/std/assert.h"
}
# 25 "c:/marmalade/6.0/s3e/h/std/c++/cassert" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2
# 29 "c:/marmalade/6.0/s3e/h/std/c++/cassert" 2
# 23 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Settings.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/c++/cmath" 1
# 21 "c:/marmalade/6.0/s3e/h/std/c++/cmath"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "c:/marmalade/6.0/s3e/h/std/c++/cmath" 2
# 33 "c:/marmalade/6.0/s3e/h/std/c++/cmath"
# 1 "c:/marmalade/6.0/s3e/h/std/math.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/math.h"
extern "C" {
# 48 "c:/marmalade/6.0/s3e/h/std/math.h"
double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);

double sin(double x);
float sinf(float x);
long double sinl(long double x);

double asin(double x);
float asinf(float x);
long double asinl(long double x);

double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);

double cos(double x);
float cosf(float x);
long double cosl(long double x);

double cosh(double x);
float coshf(float x);
long double coshl(long double x);

double acos(double x);
float acosf(float x);
long double acosl(long double x);

double tan(double x);
float tanf(float x);
long double tanl(long double x);

double atan(double x);
float atanf(float x);
long double atanl(long double x);

double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);

double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);

double fabs(double x);
float fabsf(float x);
long double fabsl(long double x);

double ceil(double x);
float ceilf(float x);
long double ceill(long double x);

double floor(double x);
float floorf(float x);
long double floorl(long double x);

double sqrt(double x);
float sqrtf(float x);
long double sqrtl(long double x);

double cbrt(double x);
float cbrtf(float x);
long double cbrtl(long double x);

double fmod(double x, double y);
float fmodf(float x, float y);
long double fmodl(long double x, long double y);

double modf(double x, double *iptr);
float modff(float x, float *iptr);
long double modfl(long double x, long double *iptr);

double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);

double exp(double x);
float expf(float x);
long double expl(long double x);

double log(double x);
float logf(float x);
long double logl(long double x);

double log10(double x);
float log10f(float x);
long double log10l(long double x);

double rint(double x);
float rintf(float x);
long double rintl(long double x);

double round(double x);
float roundf(float x);
long double roundl(long double x);

double frexp(double x, int *exp);
float frexpf(float x, int *exp);
long double frexpl(long double x, int *exp);

long int lround(double x);
long int lroundf(float x);
long int lroundl(long double x);

int64 llround(double x);
int64 llroundf(float x);
int64 llroundl(long double x);

double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);

double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);

double trunc(double x);
float truncf(float x);
long double truncl(long double x);

double hypot(double x, double y);

double copysign(double x, double y);
float copysignf(float x, float y);
long double copysignl(long double x, long double y);

int finite(double x);
# 188 "c:/marmalade/6.0/s3e/h/std/math.h"
# 1 "c:/marmalade/6.0/s3e/h/std/math_gcc.h" 1
# 33 "c:/marmalade/6.0/s3e/h/std/math_gcc.h"
int __isnanf(float);
int __isnand(double);
int __isinff(float);
int __isinfd(double);
int __signbitf(float);
int __signbitd(double);
int __fpclassifyf(float);
int __fpclassifyd(double);
int __fpclassifyl(long double);
# 189 "c:/marmalade/6.0/s3e/h/std/math.h" 2
# 213 "c:/marmalade/6.0/s3e/h/std/math.h"
}
# 34 "c:/marmalade/6.0/s3e/h/std/c++/cmath" 2
# 49 "c:/marmalade/6.0/s3e/h/std/c++/cmath"
namespace _STL {




using ::acos;
using ::asin;
using ::atan2;
using ::atan;
using ::ceil;
using ::cos;
using ::cosh;
using ::exp;
using ::fabs;
using ::floor;
using ::fmod;
using ::frexp;
using ::ldexp;
using ::log10;
using ::log;
using ::modf;
using ::pow;
using ::sin;
using ::sinh;
using ::sqrt;
using ::tan;
using ::tanh;

}



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cmath.h" 1
# 19 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cmath.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/cmath" 1
# 20 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cmath.h" 2

namespace _STL {
# 111 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cmath.h"
}





namespace _STL {


inline double abs(double __x) { return ::fabs(__x); }
inline float abs (float __x) { return ::fabs(__x); }


inline double pow(double __x, int __y) { return ::pow(__x, __y); }
inline float acos (float __x) { return ::acos(__x); }
inline float asin (float __x) { return ::asin(__x); }
inline float atan (float __x) { return ::atan(__x); }
inline float atan2(float __x, float __y) { return ::atan2(__x, __y); }
inline float ceil (float __x) { return ::ceil(__x); }
inline float cos (float __x) { return ::cos(__x); }
inline float cosh (float __x) { return ::cosh(__x); }
inline float exp (float __x) { return ::exp(__x); }

inline float fabs (float __x) { return ::fabs(__x); }

inline float floor(float __x) { return ::floor(__x); }
inline float fmod (float __x, float __y) { return ::fmod(__x, __y); }
inline float frexp(float __x, int* __y) { return ::frexp(__x, __y); }
inline float ldexp(float __x, int __y) { return ::ldexp(__x, __y); }


inline float modf (float __x, float* __y) {
  double __dd[2];
  double __res = ::modf((double)__x, __dd);
  __y[0] = (float)__dd[0] ; __y[1] = (float)__dd[1];
  return (float)__res;
}
# 157 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cmath.h"
inline float log (float __x) { return ::log(__x); }
inline float log10(float __x) { return ::log10(__x); }
inline float pow (float __x, float __y) { return ::pow(__x, __y); }
inline float pow (float __x, int __y) { return ::pow(__x, __y); }
inline float sin (float __x) { return ::sin(__x); }
inline float sinh (float __x) { return ::sinh(__x); }
inline float sqrt (float __x) { return ::sqrt(__x); }
inline float tan (float __x) { return ::tan(__x); }
inline float tanh (float __x) { return ::tanh(__x); }




inline long double abs (long double __x) { return ::fabs((double)__x); }

inline long double acos (long double __x) { return ::acos(__x); }
inline long double asin (long double __x) { return ::asin(__x); }
inline long double atan (long double __x) { return ::atan(__x); }
inline long double atan2(long double __x, long double __y) { return ::atan2(__x, __y); }
inline long double ceil (long double __x) { return ::ceil(__x); }
inline long double cos (long double __x) { return ::cos(__x); }
inline long double cosh (long double __x) { return ::cosh(__x); }
inline long double exp (long double __x) { return ::exp(__x); }
inline long double fabs (long double __x) { return ::fabs(__x); }
inline long double floor(long double __x) { return ::floor(__x); }
inline long double fmod (long double __x, long double __y) { return ::fmod(__x, __y); }
inline long double frexp(long double __x, int* __y) { return ::frexp(__x, __y); }
inline long double ldexp(long double __x, int __y) { return ::ldexp(__x, __y); }

inline long double modf (long double __x, long double* __y) {
  double __dd[2];
  double __res = ::modf((double)__x, __dd);
  __y[0] = (long double)__dd[0] ; __y[1] = (long double)__dd[1];
  return (long double)__res;
}
inline long double log (long double __x) { return ::log(__x); }
inline long double log10(long double __x) { return ::log10(__x); }
inline long double pow (long double __x, long double __y) { return ::pow(__x, __y); }
inline long double pow (long double __x, int __y) { return ::pow(__x, __y); }
inline long double sin (long double __x) { return ::sin(__x); }
inline long double sinh (long double __x) { return ::sinh(__x); }
inline long double sqrt (long double __x) { return ::sqrt(__x); }
inline long double tan (long double __x) { return ::tan(__x); }
inline long double tanh (long double __x) { return ::tanh(__x); }


}
# 82 "c:/marmalade/6.0/s3e/h/std/c++/cmath" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2
# 86 "c:/marmalade/6.0/s3e/h/std/c++/cmath" 2
# 24 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Settings.h" 2




typedef signed char int8;
typedef signed short int16;
typedef signed int int32;
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;
typedef float float32;
typedef double float64;
# 129 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Settings.h"
void* b2Alloc(int32 size);


void b2Free(void* mem);



struct b2Version
{
 int32 major;
 int32 minor;
 int32 revision;
};


extern b2Version b2_version;
# 23 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2BlockAllocator.h" 2

const int32 b2_chunkSize = 16 * 1024;
const int32 b2_maxBlockSize = 640;
const int32 b2_blockSizes = 14;
const int32 b2_chunkArrayIncrement = 128;

struct b2Block;
struct b2Chunk;




class b2BlockAllocator
{
public:
 b2BlockAllocator();
 ~b2BlockAllocator();


 void* Allocate(int32 size);


 void Free(void* p, int32 size);

 void Clear();

private:

 b2Chunk* m_chunks;
 int32 m_chunkCount;
 int32 m_chunkSpace;

 b2Block* m_freeLists[b2_blockSizes];

 static int32 s_blockSizes[b2_blockSizes];
 static uint8 s_blockSizeLookup[b2_maxBlockSize + 1];
 static bool s_blockSizeLookupInitialized;
};
# 23 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2Shape.h" 2
# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Math.h" 1
# 25 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Math.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/cfloat" 1
# 21 "c:/marmalade/6.0/s3e/h/std/c++/cfloat"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "c:/marmalade/6.0/s3e/h/std/c++/cfloat" 2







# 1 "c:/marmalade/6.0/s3e/h/ext/../std/float.h" 1
# 31 "c:/marmalade/6.0/s3e/h/ext/../std/float.h"
  extern "C" {
# 109 "c:/marmalade/6.0/s3e/h/ext/../std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "c:/marmalade/6.0/s3e/h/ext/../std/float.h"
    }
# 30 "c:/marmalade/6.0/s3e/h/std/c++/cfloat" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2
# 34 "c:/marmalade/6.0/s3e/h/std/c++/cfloat" 2
# 26 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Math.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/c++/cstddef" 1
# 23 "c:/marmalade/6.0/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 2
# 24 "c:/marmalade/6.0/s3e/h/std/c++/cstddef" 2
# 37 "c:/marmalade/6.0/s3e/h/std/c++/cstddef"
# 1 "c:/marmalade/6.0/s3e/h/ext/../std/stddef.h" 1
# 38 "c:/marmalade/6.0/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2
# 49 "c:/marmalade/6.0/s3e/h/std/c++/cstddef" 2
# 27 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Math.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/c++/limits" 1
# 24 "c:/marmalade/6.0/s3e/h/std/c++/limits"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 2
# 25 "c:/marmalade/6.0/s3e/h/std/c++/limits" 2



         



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h" 1
# 30 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/climits" 1
# 32 "c:/marmalade/6.0/s3e/h/std/c++/climits"
# 1 "c:/marmalade/6.0/s3e/h/std/limits.h" 1
# 33 "c:/marmalade/6.0/s3e/h/std/c++/climits" 2
# 31 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h" 2







# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cwchar.h" 1
# 21 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cwchar.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/cwchar" 1
# 49 "c:/marmalade/6.0/s3e/h/std/c++/cwchar"
# 1 "c:/marmalade/6.0/s3e/h/ext/../std/wchar.h" 1
# 16 "c:/marmalade/6.0/s3e/h/ext/../std/wchar.h"
# 1 "c:/marmalade/6.0/s3e/h/std/stdio.h" 1
# 19 "c:/marmalade/6.0/s3e/h/std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "c:/marmalade/6.0/s3e/h/std/stdio.h"
extern "C" {
# 54 "c:/marmalade/6.0/s3e/h/std/stdio.h"
extern FILE *__aeabi_stdin;
extern FILE *__aeabi_stdout;
extern FILE *__aeabi_stderr;
# 66 "c:/marmalade/6.0/s3e/h/std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);

# 1 "c:/marmalade/6.0/s3e/h/std/stdarg.h" 1
# 54 "c:/marmalade/6.0/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 162 "c:/marmalade/6.0/s3e/h/std/stdio.h" 2

int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 17 "c:/marmalade/6.0/s3e/h/ext/../std/wchar.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/time.h" 1
# 19 "c:/marmalade/6.0/s3e/h/std/time.h"
typedef long time_t;





typedef long clock_t;




struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};



struct timespec
{
    time_t tv_sec;
    long int tv_nsec;
};

extern "C" {






time_t time(time_t *t);

void tzset(void);

char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);

char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);

struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);

struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);

time_t mktime(struct tm *tm);

size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);

clock_t clock(void);

double difftime(time_t time1, time_t time0);

int nanosleep(const struct timespec *req, struct timespec *rem);



    extern char *_tzname[2];
    extern int _daylight;
    extern long int _timezone;
# 101 "c:/marmalade/6.0/s3e/h/std/time.h"
typedef int clockid_t;

int clock_getres(clockid_t clk_id, struct timespec *res);

int clock_gettime(clockid_t clk_id, struct timespec *tp);

int clock_settime(clockid_t clk_id, const struct timespec *tp);

}

# 1 "c:/marmalade/6.0/s3e/h/std/sys/time.h" 1
# 16 "c:/marmalade/6.0/s3e/h/std/sys/time.h"
# 1 "c:/marmalade/6.0/s3e/h/std/time.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/sys/time.h" 2



extern "C" {

typedef long suseconds_t;
struct timeval
{
    time_t tv_sec;
    suseconds_t tv_usec;
};

struct _timezone
{
    int tz_minuteswest;
    int tz_dsttime;
};

int gettimeofday(struct timeval *tv, struct _timezone *tz);
int settimeofday(const struct timeval *tv , const struct _timezone *tz);

int utimes(const char *filename, const struct timeval times[2]);

}
# 112 "c:/marmalade/6.0/s3e/h/std/time.h" 2
# 18 "c:/marmalade/6.0/s3e/h/ext/../std/wchar.h" 2
# 1 "c:/marmalade/6.0/s3e/h/std/wctype.h" 1
# 18 "c:/marmalade/6.0/s3e/h/std/wctype.h"
extern "C" {

typedef const int32* wctrans_t;

wctype_t wctype(const char *name);
wctrans_t wctrans(const char *name);
int iswctype(wint_t wc, wctype_t desc);
wint_t towctrans(wint_t wc, wctrans_t desc);

int towupper(int c);
int towlower(int c);
int iswalnum(int c);
int iswalpha(int c);
int iswascii(int c);
int iswblank(int c);
int iswcntrl(int c);
int iswdigit(int c);
int iswgraph(int c);
int iswlower(int c);
int iswprint(int c);
int iswpunct(int c);
int iswspace(int c);
int iswupper(int c);
int iswxdigit(int c);

}
# 19 "c:/marmalade/6.0/s3e/h/ext/../std/wchar.h" 2


extern "C" {



typedef int mbstate_t;

wchar_t fgetwc(FILE *stream);
wchar_t *fgetws(wchar_t *ws, int n, FILE *stream);
wchar_t fputwc(wchar_t wc, FILE *stream);
wchar_t putwc(wchar_t wc, FILE *stream);
wchar_t getwc(FILE *stream);
wchar_t getwchar(void);
wchar_t ungetwc(wchar_t wc, FILE *stream);

int fputws(const wchar_t *ws, FILE *stream);
int fwide(FILE *stream, int mode);

int mbsinit(const mbstate_t *ps);
wchar_t btowc(int c);
size_t mbrlen(const char *s, size_t n, mbstate_t *ps);
size_t mbsrtowcs(wchar_t *dest, const char **src, size_t len, mbstate_t *ps);
size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps);
wchar_t putwchar(wchar_t wc);
wchar_t *wmemset(wchar_t *wcs, wchar_t wc, size_t n);
wchar_t *wcspbrk(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcsrchr(const wchar_t *wcs, wchar_t wc);
wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n);
int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcslen(const wchar_t *s);
size_t wcsnlen(const wchar_t *s, size_t n);
size_t wcsrtombs(char *dest, const wchar_t **src, size_t len, mbstate_t *ps);
wchar_t *wmemmove(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wmemcpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcsstr(const wchar_t *haystack, const wchar_t *needle);
wchar_t *wcschr(const wchar_t *wcs, wchar_t wc);
size_t wcsspn(const wchar_t *wcs, const wchar_t *accept);
wchar_t *wcstok(wchar_t *wcs, const wchar_t *delim, wchar_t **ptr);
wchar_t *wcsncpy(wchar_t *dest, const wchar_t *src, size_t n);
wchar_t *wcscat(wchar_t *dest, const wchar_t *src);
wchar_t *wcscpy(wchar_t *dest, const wchar_t *src);
size_t wcsxfrm (wchar_t *s1, const wchar_t *s2, size_t n);
float wcstof(const wchar_t *nptr, wchar_t **endptr);

int wcscoll (const wchar_t *s1, const wchar_t *s2);

int wprintf(const wchar_t *format, ...);
int fwprintf(FILE *stream, const wchar_t *format, ...);
int swprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, ...);

int wscanf(const wchar_t *format, ...);
int fwscanf(FILE *stream, const wchar_t *format, ...);
int swscanf(const wchar_t *str, const wchar_t *format, ...);

size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps);
int wcscmp(const wchar_t *s1, const wchar_t *s2);
int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);
size_t wcsftime(wchar_t *s, size_t maxsize, const wchar_t *format, const struct tm *tp);
int wctob(wint_t c);
size_t wcscspn(const wchar_t *wcs, const wchar_t *reject);
wchar_t *wcsncat(wchar_t *dest, const wchar_t *src, size_t n);

int64 wcstoll(wchar_t *nptr, wchar_t **endptr, int base);
uint64 wcstoull(wchar_t *nptr, wchar_t **endptr, int base);
long int wcstol(const wchar_t *nptr, wchar_t **endptr, int base);
unsigned long int wcstoul(const wchar_t *nptr, wchar_t **endptr, int base);
double wcstod(const wchar_t *nptr, wchar_t **endptr);
long double wcstold(wchar_t *nptr, wchar_t **endptr);

int vwprintf(const wchar_t *format, va_list args);
int vfwprintf(FILE *stream, const wchar_t *format, va_list args);
int vswprintf(wchar_t *wcs, size_t maxlen, const wchar_t *format, va_list args);

int vfwscanf(FILE *s, const wchar_t *format, va_list arg);
int vswscanf(wchar_t *s, wchar_t *format, va_list arg);
int vwscanf(wchar_t *format, va_list arg);






}
# 50 "c:/marmalade/6.0/s3e/h/std/c++/cwchar" 2
# 107 "c:/marmalade/6.0/s3e/h/std/c++/cwchar"
namespace _STL {





using ::wint_t;






using ::size_t;


using ::mbstate_t;
# 147 "c:/marmalade/6.0/s3e/h/std/c++/cwchar"
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;





using ::fwide;

using ::fwprintf;
using ::fwscanf;
using ::getwchar;



using ::getwc;
using ::ungetwc;

using ::putwc;
using ::putwchar;




using ::swprintf;
using ::swscanf;
using ::vfwprintf;
using ::vwprintf;
using ::vswprintf;


using ::wcsftime;

using ::wcstok;




using ::wcscat;
using ::wcsrchr;
using ::wcscmp;
using ::wcscoll;

using ::wcscpy;
using ::wcscspn;

using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcschr;

using ::wcsspn;
using ::wcsxfrm;





using ::wcstod;
using ::wcstol;





using ::wcsstr;
using ::wmemchr;




using ::wctob;
using ::wmemcmp;

using ::wmemmove;
using ::wprintf;
using ::wscanf;



using ::wmemcpy;
using ::wmemset;



}
# 22 "c:/marmalade/6.0/s3e/h/std/c++/stl/_cwchar.h" 2
# 39 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h" 2


namespace _STL {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};



template <class __number>
class _Numeric_limits_base {
public:

  static __number ( min)() { return __number(); }
  static __number ( max)() { return __number(); }




  static const int


  digits = 0,
  digits10 = 0,
  radix = 0,
  min_exponent = 0,
  min_exponent10 = 0,
  max_exponent = 0,
  max_exponent10 = 0






  ;
  static const float_denorm_style has_denorm = denorm_absent;
  static const float_round_style round_style = round_toward_zero;
  static const bool


    is_specialized = false,
    is_signed = false,
    is_integer = false,
    is_exact = false,
    has_infinity = false,
    has_quiet_NaN = false,
    has_signaling_NaN = false,
    has_denorm_loss = false,
    is_iec559 = false,
    is_bounded = false,
    is_modulo = false,
    traps = false,
    tinyness_before = false



  ;

  static __number epsilon() { return __number(); }
  static __number round_error() { return __number(); }

  static __number infinity() { return __number(); }
  static __number quiet_NaN() { return __number(); }
  static __number signaling_NaN() { return __number(); }
  static __number denorm_min() { return __number(); }


};
# 135 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h"
template <class _Int,
          _Int __imin,
          _Int __imax,
          int __idigits, bool __ismod>
class _Integer_limits : public _Numeric_limits_base<_Int>
{
public:

  static _Int ( min) () { return (_Int)__imin; }
  static _Int ( max) () { return (_Int)__imax; }




  static const int

  digits = (__idigits < 0) ?
  ((int)((sizeof(_Int) * (8))) - ((__imin == 0) ? 0 : 1))
  : (__idigits),
  digits10 = (digits * 301UL) / 1000,
  radix = 2

  ;
  static const bool



  is_specialized = true,
  is_signed = (__imin != 0),
  is_integer = true,
  is_exact = true,
  is_bounded = true,
  is_modulo = __ismod



  ;
};


template <class __number,
         int __Digits, int __Digits10,
         int __MinExp, int __MaxExp,
         int __MinExp10, int __MaxExp10,
         bool __IsIEC559,
         float_round_style __RoundStyle>
class _Floating_limits : public _Numeric_limits_base<__number>
{
public:




  static const int


  digits = __Digits,
  digits10 = __Digits10,

  radix = ( 2 ),
  min_exponent = __MinExp,
  max_exponent = __MaxExp,
  min_exponent10 = __MinExp10,
  max_exponent10 = __MaxExp10






  ;
  static const float_denorm_style has_denorm = denorm_indeterminate;
  static const float_round_style round_style = __RoundStyle;
  static const bool


  is_specialized = true,
  is_signed = true,


   has_infinity = true,
   has_quiet_NaN = true,
   has_signaling_NaN= true,






  has_denorm_loss = false,
  is_iec559 = __IsIEC559,
  is_bounded = true,
  traps = true,
  tinyness_before= false




  ;

};





template<class _Tp>
class numeric_limits : public _Numeric_limits_base<_Tp> {};





template<>
class numeric_limits<bool>
  : public _Integer_limits<bool, false, true, 1, false>
{};



template<>
class numeric_limits<char>
  : public _Integer_limits<char, 0, 255, -1, true>
{};


template<>
class numeric_limits<signed char>
  : public _Integer_limits<signed char, (-128), 127, -1, true>
{};


template<>
class numeric_limits<unsigned char>
  : public _Integer_limits<unsigned char, 0, 255, -1, true>
{};
# 281 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h"
template<>
class numeric_limits<short>
  : public _Integer_limits<short, (-0x7fff - 1), 0x7fff, -1, true>
{};

template<>
class numeric_limits<unsigned short>
  : public _Integer_limits<unsigned short, 0, 0xffff, -1, true>
{};







template<>
class numeric_limits<int>
  : public _Integer_limits<int, (-0x7fffffffL - 1), 0x7fffffffL, -1, true>
{};

template<>
class numeric_limits<unsigned int>
  : public _Integer_limits<unsigned int, 0, 0xffffffffUL, -1, true>
{};

template<>
class numeric_limits<long>
  : public _Integer_limits<long, (-0x7fffffffL - 1), 0x7fffffffL, -1, true>
{};

template<>
class numeric_limits<unsigned long>
  : public _Integer_limits<unsigned long, 0, 0xffffffffUL, -1, true>
{};
# 359 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h"
template<>
class numeric_limits<long long>
  : public _Numeric_limits_base<long long>
{
public:

  static long long ( min) () { return (-0x7fffffffffffffffLL -1LL); }
  static long long ( max) () { return 0x7fffffffffffffffLL; }




  static const int

  digits = ((int)((sizeof(long long) * (8))) - 1),
  digits10 = (digits * 301UL) / 1000,
  radix = 2

  ;
  static const bool



  is_specialized = true,
  is_signed = true,
  is_integer = true,
  is_exact = true,
  is_bounded = true,
  is_modulo = true



  ;
};

template<>
class numeric_limits<unsigned long long>
  : public _Numeric_limits_base<unsigned long long>
{
public:

  static unsigned long long ( min) () { return 0ULL; }
  static unsigned long long ( max) () { return 0xffffffffffffffffULL; }




  static const int

  digits = ((int)((sizeof(unsigned long long) * (8)))),
  digits10 = (digits * 301UL) / 1000,
  radix = 2

  ;
  static const bool



  is_specialized = true,
  is_signed = false,
  is_integer = true,
  is_exact = true,
  is_bounded = true,
  is_modulo = true



  ;
};







union _F_rep
{
  unsigned short rep[2];
  float val;
};
union _D_rep
{
  unsigned short rep[4];
  double val;
};


union _L_rep
{
  unsigned short rep[8];
  long double val;
};


template <class __dummy>
class _LimG
{
public:
  static const _F_rep _F_inf;
  static const _F_rep _F_qNaN;
  static const _F_rep _F_sNaN;
  static const _D_rep _D_inf;
  static const _D_rep _D_qNaN;
  static const _D_rep _D_sNaN;


  static const _L_rep _L_inf;
  static const _L_rep _L_qNaN;
  static const _L_rep _L_sNaN;

};





template<> class numeric_limits<float>
  : public _Floating_limits<float,
                            24,
                            6,
                            (-125),
                            128,
                            (-37),
                            38,
                            true,
                            round_to_nearest>
{
public:
  static float ( min) () { return 1.175494351e-38F; }
  static float denorm_min() { return 1.175494351e-38F; }
  static float ( max) () { return 3.402823466e+38F; }
  static float epsilon() { return 1.19209290e-7F; }
  static float round_error() { return 0.5f; }
  static float infinity() { return _LimG<bool>::_F_inf.val; }
  static float quiet_NaN() { return _LimG<bool>::_F_qNaN.val; }
  static float signaling_NaN() { return _LimG<bool>::_F_sNaN.val; }
};

template<> class numeric_limits<double>
  : public _Floating_limits<double,
                            53,
                            15,
                            (-1021),
                            1024,
                            (-307),
                            308,
                            true,
                            round_to_nearest>
{
public:
  static double ( min)() { return 2.22507385850720138e-308; }
  static double denorm_min() { return 2.22507385850720138e-308; }
  static double ( max)() { return 1.79769313486231571e+308; }
  static double epsilon() { return 2.2204460492503131e-16; }
  static double round_error() { return 0.5; }
  static double infinity() { return _LimG<bool>::_D_inf.val; }
  static double quiet_NaN(){ return _LimG<bool>::_D_qNaN.val; }
  static double signaling_NaN() { return _LimG<bool>::_D_sNaN.val; }
};



template<>
class numeric_limits<long double>
  : public _Floating_limits<long double,
                            53,
                            15,
                            (-1021),
                            1024,
                            (-307),
                            308,
                            false,
                            round_to_nearest>
{
public:
  static long double ( min) () { return 2.22507385850720138e-308L; }
  static long double denorm_min() { return 2.22507385850720138e-308L; }
  static long double ( max) () { return 1.79769313486231571e+308L; }
  static long double epsilon() { return 2.2204460492503131e-16L; }
  static long double round_error() { return 4; }
  static long double infinity() { return _LimG<bool>::_L_inf.val; }
  static long double quiet_NaN() { return _LimG<bool>::_L_qNaN.val; }
  static long double signaling_NaN() { return _LimG<bool>::_L_sNaN.val; }
};





}


# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.c" 1
# 30 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.c"
namespace _STL {







template <class __number> const bool _Numeric_limits_base<__number>:: is_specialized;
template <class __number> const int _Numeric_limits_base<__number>:: digits;
template <class __number> const int _Numeric_limits_base<__number>:: digits10;
template <class __number> const bool _Numeric_limits_base<__number>:: is_signed;
template <class __number> const bool _Numeric_limits_base<__number>:: is_integer;
template <class __number> const bool _Numeric_limits_base<__number>:: is_exact;
template <class __number> const int _Numeric_limits_base<__number>:: radix;
template <class __number> const int _Numeric_limits_base<__number>:: min_exponent;
template <class __number> const int _Numeric_limits_base<__number>:: max_exponent;
template <class __number> const int _Numeric_limits_base<__number>:: min_exponent10;
template <class __number> const int _Numeric_limits_base<__number>:: max_exponent10;
template <class __number> const bool _Numeric_limits_base<__number>:: has_infinity;
template <class __number> const bool _Numeric_limits_base<__number>:: has_quiet_NaN;
template <class __number> const bool _Numeric_limits_base<__number>:: has_signaling_NaN;
template <class __number> const float_denorm_style _Numeric_limits_base<__number>:: has_denorm;
template <class __number> const bool _Numeric_limits_base<__number>:: has_denorm_loss;
template <class __number> const bool _Numeric_limits_base<__number>:: is_iec559;
template <class __number> const bool _Numeric_limits_base<__number>:: is_bounded;
template <class __number> const bool _Numeric_limits_base<__number>:: is_modulo;
template <class __number> const bool _Numeric_limits_base<__number>:: traps;
template <class __number> const bool _Numeric_limits_base<__number>:: tinyness_before;
template <class __number> const float_round_style _Numeric_limits_base<__number>:: round_style;







template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_specialized;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits;


template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: digits10;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_signed;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_integer;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_exact;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const int _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: radix;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_bounded;
template <class _Int, _Int __imin, _Int __imax, int __idigits, bool __ismod> const bool _Integer_limits<_Int, __imin, __imax, __idigits, __ismod>:: is_modulo;
# 91 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.c"
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_specialized;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: digits;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: digits10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_signed;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: radix;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: min_exponent;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: max_exponent;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: min_exponent10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const int _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: max_exponent10;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_infinity;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_quiet_NaN;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_signaling_NaN;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const float_denorm_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_denorm;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: has_denorm_loss;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_iec559;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: is_bounded;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: traps;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const bool _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: tinyness_before;
template <class __number, int __Digits, int __Digits10, int __MinExp, int __MaxExp, int __MinExp10, int __MaxExp10, bool __IsIEC559, float_round_style __RoundStyle> const float_round_style _Floating_limits< __number, __Digits, __Digits10, __MinExp, __MaxExp, __MinExp10, __MaxExp10, __IsIEC559, __RoundStyle>:: round_style;
# 290 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.c"
}
# 553 "c:/marmalade/6.0/s3e/h/std/c++/stl/_limits.h" 2
# 33 "c:/marmalade/6.0/s3e/h/std/c++/limits" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2
# 37 "c:/marmalade/6.0/s3e/h/std/c++/limits" 2
# 28 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Common/b2Math.h" 2



inline bool b2IsValid(float32 x)
{
 if (x != x)
 {

  return false;
 }

 float32 infinity = _STL::numeric_limits<float32>::infinity();
 return -infinity < x && x < infinity;
}


inline float32 b2InvSqrt(float32 x)
{
 union
 {
  float32 x;
  int32 i;
 } convert;

 convert.x = x;
 float32 xhalf = 0.5f * x;
 convert.i = 0x5f3759df - (convert.i >> 1);
 x = convert.x;
 x = x * (1.5f - xhalf * x * x);
 return x;
}





struct b2Vec2
{

 b2Vec2() {}


 b2Vec2(float32 x, float32 y) : x(x), y(y) {}


 void SetZero() { x = 0.0f; y = 0.0f; }


 void Set(float32 x_, float32 y_) { x = x_; y = y_; }


 b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }


 float32 operator () (int32 i) const
 {
  return (&x)[i];
 }


 float32& operator () (int32 i)
 {
  return (&x)[i];
 }


 void operator += (const b2Vec2& v)
 {
  x += v.x; y += v.y;
 }


 void operator -= (const b2Vec2& v)
 {
  x -= v.x; y -= v.y;
 }


 void operator *= (float32 a)
 {
  x *= a; y *= a;
 }


 float32 Length() const
 {
  return _STL::sqrt(x * x + y * y);
 }



 float32 LengthSquared() const
 {
  return x * x + y * y;
 }


 float32 Normalize()
 {
  float32 length = Length();
  if (length < 1.19209290e-7F)
  {
   return 0.0f;
  }
  float32 invLength = 1.0f / length;
  x *= invLength;
  y *= invLength;

  return length;
 }


 bool IsValid() const
 {
  return b2IsValid(x) && b2IsValid(y);
 }


 b2Vec2 Skew() const
 {
  return b2Vec2(-y, x);
 }

 float32 x, y;
};


struct b2Vec3
{

 b2Vec3() {}


 b2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}


 void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }


 void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }


 b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }


 void operator += (const b2Vec3& v)
 {
  x += v.x; y += v.y; z += v.z;
 }


 void operator -= (const b2Vec3& v)
 {
  x -= v.x; y -= v.y; z -= v.z;
 }


 void operator *= (float32 s)
 {
  x *= s; y *= s; z *= s;
 }

 float32 x, y, z;
};


struct b2Mat22
{

 b2Mat22() {}


 b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
 {
  ex.x = a11; ex.y = a21;
  ey.x = a12; ey.y = a22;
 }


 void Set(const b2Vec2& c1, const b2Vec2& c2)
 {
  ex = c1;
  ey = c2;
 }


 void SetIdentity()
 {
  ex.x = 1.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 1.0f;
 }


 void SetZero()
 {
  ex.x = 0.0f; ey.x = 0.0f;
  ex.y = 0.0f; ey.y = 0.0f;
 }

 b2Mat22 GetInverse() const
 {
  float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
  b2Mat22 B;
  float32 det = a * d - b * c;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  B.ex.x = det * d; B.ey.x = -det * b;
  B.ex.y = -det * c; B.ey.y = det * a;
  return B;
 }



 b2Vec2 Solve(const b2Vec2& b) const
 {
  float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
  float32 det = a11 * a22 - a12 * a21;
  if (det != 0.0f)
  {
   det = 1.0f / det;
  }
  b2Vec2 x;
  x.x = det * (a22 * b.x - a12 * b.y);
  x.y = det * (a11 * b.y - a21 * b.x);
  return x;
 }

 b2Vec2 ex, ey;
};


struct b2Mat33
{

 b2Mat33() {}


 b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
 {
  ex = c1;
  ey = c2;
  ez = c3;
 }


 void SetZero()
 {
  ex.SetZero();
  ey.SetZero();
  ez.SetZero();
 }



 b2Vec3 Solve33(const b2Vec3& b) const;




 b2Vec2 Solve22(const b2Vec2& b) const;

 b2Vec3 ex, ey, ez;
};


struct b2Rot
{
 b2Rot() {}


 explicit b2Rot(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void Set(float32 angle)
 {

  s = sinf(angle);
  c = cosf(angle);
 }


 void SetIdentity()
 {
  s = 0.0f;
  c = 1.0f;
 }


 float32 GetAngle() const
 {
  return _STL::atan2(s, c);
 }


 b2Vec2 GetXAxis() const
 {
  return b2Vec2(c, s);
 }


 b2Vec2 GetYAxis() const
 {
  return b2Vec2(-s, c);
 }


 float32 s, c;
};



struct b2Transform
{

 b2Transform() {}


 b2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}


 void SetIdentity()
 {
  p.SetZero();
  q.SetIdentity();
 }


 void Set(const b2Vec2& position, float32 angle)
 {
  p = position;
  q.Set(angle);
 }

 b2Vec2 p;
 b2Rot q;
};





struct b2Sweep
{


 void GetTransform(b2Transform* xfb, float32 beta) const;



 void Advance(float32 alpha);


 void Normalize();

 b2Vec2 localCenter;
 b2Vec2 c0, c;
 float32 a0, a;



 float32 alpha0;
};


extern const b2Vec2 b2Vec2_zero;


inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.x + a.y * b.y;
}


inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
{
 return a.x * b.y - a.y * b.x;
}



inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
{
 return b2Vec2(s * a.y, -s * a.x);
}



inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
{
 return b2Vec2(-s * a.y, s * a.x);
}



inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
}



inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
{
 return b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));
}


inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x + b.x, a.y + b.y);
}


inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(a.x - b.x, a.y - b.y);
}

inline b2Vec2 operator * (float32 s, const b2Vec2& a)
{
 return b2Vec2(s * a.x, s * a.y);
}

inline bool operator == (const b2Vec2& a, const b2Vec2& b)
{
 return a.x == b.x && a.y == b.y;
}

inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return c.Length();
}

inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
{
 b2Vec2 c = a - b;
 return b2Dot(c, c);
}

inline b2Vec3 operator * (float32 s, const b2Vec3& a)
{
 return b2Vec3(s * a.x, s * a.y, s * a.z);
}


inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
}


inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
}


inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
{
 return a.x * b.x + a.y * b.y + a.z * b.z;
}


inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
{
 return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(A.ex + B.ex, A.ey + B.ey);
}


inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
{
 return b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));
}


inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
{
 b2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));
 b2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));
 return b2Mat22(c1, c2);
}


inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
{
 return v.x * A.ex + v.y * A.ey + v.z * A.ez;
}


inline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.s * r.c + q.c * r.s;
 qr.c = q.c * r.c - q.s * r.s;
 return qr;
}


inline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)
{




 b2Rot qr;
 qr.s = q.s * r.c + q.c * r.s;
 qr.c = q.c * r.c - q.s * r.s;
 return qr;
}


inline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
}


inline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)
{
 return b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
}

inline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)
{
 float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
 float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;

 return b2Vec2(x, y);
}

inline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)
{
 float32 px = v.x - T.p.x;
 float32 py = v.y - T.p.y;
 float32 x = (T.q.c * px + T.q.s * py);
 float32 y = (-T.q.s * px + T.q.c * py);

 return b2Vec2(x, y);
}



inline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2Mul(A.q, B.q);
 C.p = b2Mul(A.q, B.p) + A.p;
 return C;
}



inline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)
{
 b2Transform C;
 C.q = b2MulT(A.q, B.q);
 C.p = b2MulT(A.q, B.p - A.p);
 return C;
}

template <typename T>
inline T b2Abs(T a)
{
 return a > T(0) ? a : -a;
}

inline b2Vec2 b2Abs(const b2Vec2& a)
{
 return b2Vec2(b2Abs(a.x), b2Abs(a.y));
}

inline b2Mat22 b2Abs(const b2Mat22& A)
{
 return b2Mat22(b2Abs(A.ex), b2Abs(A.ey));
}

template <typename T>
inline T b2Min(T a, T b)
{
 return a < b ? a : b;
}

inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
}

template <typename T>
inline T b2Max(T a, T b)
{
 return a > b ? a : b;
}

inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
{
 return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
}

template <typename T>
inline T b2Clamp(T a, T low, T high)
{
 return b2Max(low, b2Min(a, high));
}

inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
{
 return b2Max(low, b2Min(a, high));
}

template<typename T> inline void b2Swap(T& a, T& b)
{
 T tmp = a;
 a = b;
 b = tmp;
}






inline uint32 b2NextPowerOfTwo(uint32 x)
{
 x |= (x >> 1);
 x |= (x >> 2);
 x |= (x >> 4);
 x |= (x >> 8);
 x |= (x >> 16);
 return x + 1;
}

inline bool b2IsPowerOfTwo(uint32 x)
{
 bool result = x > 0 && (x & (x - 1)) == 0;
 return result;
}

inline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const
{
 xf->p = (1.0f - beta) * c0 + beta * c;
 float32 angle = (1.0f - beta) * a0 + beta * a;
 xf->q.Set(angle);


 xf->p -= b2Mul(xf->q, localCenter);
}

inline void b2Sweep::Advance(float32 alpha)
{
 ((void)0);
 float32 beta = (alpha - alpha0) / (1.0f - alpha0);
 c0 = (1.0f - beta) * c0 + beta * c;
 a0 = (1.0f - beta) * a0 + beta * a;
 alpha0 = alpha;
}


inline void b2Sweep::Normalize()
{
 float32 twoPi = 2.0f * 3.14159265359f;
 float32 d = twoPi * floorf(a0 / twoPi);
 a0 -= d;
 a -= d;
}
# 24 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2Shape.h" 2
# 1 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/b2Collision.h" 1
# 29 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/b2Collision.h"
class b2Shape;
class b2CircleShape;
class b2EdgeShape;
class b2PolygonShape;

const uint8 b2_nullFeature = 255;



struct b2ContactFeature
{
 enum Type
 {
  e_vertex = 0,
  e_face = 1
 };

 uint8 indexA;
 uint8 indexB;
 uint8 typeA;
 uint8 typeB;
};


union b2ContactID
{
 b2ContactFeature cf;
 uint32 key;
};
# 69 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/b2Collision.h"
struct b2ManifoldPoint
{
 b2Vec2 localPoint;
 float32 normalImpulse;
 float32 tangentImpulse;
 b2ContactID id;
};
# 93 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/b2Collision.h"
struct b2Manifold
{
 enum Type
 {
  e_circles,
  e_faceA,
  e_faceB
 };

 b2ManifoldPoint points[2];
 b2Vec2 localNormal;
 b2Vec2 localPoint;
 Type type;
 int32 pointCount;
};


struct b2WorldManifold
{




 void Initialize(const b2Manifold* manifold,
     const b2Transform& xfA, float32 radiusA,
     const b2Transform& xfB, float32 radiusB);

 b2Vec2 normal;
 b2Vec2 points[2];
};


enum b2PointState
{
 b2_nullState,
 b2_addState,
 b2_persistState,
 b2_removeState
};



void b2GetPointStates(b2PointState state1[2], b2PointState state2[2],
       const b2Manifold* manifold1, const b2Manifold* manifold2);


struct b2ClipVertex
{
 b2Vec2 v;
 b2ContactID id;
};


struct b2RayCastInput
{
 b2Vec2 p1, p2;
 float32 maxFraction;
};



struct b2RayCastOutput
{
 b2Vec2 normal;
 float32 fraction;
};


struct b2AABB
{

 bool IsValid() const;


 b2Vec2 GetCenter() const
 {
  return 0.5f * (lowerBound + upperBound);
 }


 b2Vec2 GetExtents() const
 {
  return 0.5f * (upperBound - lowerBound);
 }


 float32 GetPerimeter() const
 {
  float32 wx = upperBound.x - lowerBound.x;
  float32 wy = upperBound.y - lowerBound.y;
  return 2.0f * (wx + wy);
 }


 void Combine(const b2AABB& aabb)
 {
  lowerBound = b2Min(lowerBound, aabb.lowerBound);
  upperBound = b2Max(upperBound, aabb.upperBound);
 }


 void Combine(const b2AABB& aabb1, const b2AABB& aabb2)
 {
  lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
  upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
 }


 bool Contains(const b2AABB& aabb) const
 {
  bool result = true;
  result = result && lowerBound.x <= aabb.lowerBound.x;
  result = result && lowerBound.y <= aabb.lowerBound.y;
  result = result && aabb.upperBound.x <= upperBound.x;
  result = result && aabb.upperBound.y <= upperBound.y;
  return result;
 }

 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;

 b2Vec2 lowerBound;
 b2Vec2 upperBound;
};


void b2CollideCircles(b2Manifold* manifold,
       const b2CircleShape* circleA, const b2Transform& xfA,
       const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygonAndCircle(b2Manifold* manifold,
          const b2PolygonShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollidePolygons(b2Manifold* manifold,
        const b2PolygonShape* polygonA, const b2Transform& xfA,
        const b2PolygonShape* polygonB, const b2Transform& xfB);


void b2CollideEdgeAndCircle(b2Manifold* manifold,
          const b2EdgeShape* polygonA, const b2Transform& xfA,
          const b2CircleShape* circleB, const b2Transform& xfB);


void b2CollideEdgeAndPolygon(b2Manifold* manifold,
          const b2EdgeShape* edgeA, const b2Transform& xfA,
          const b2PolygonShape* circleB, const b2Transform& xfB);


int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
       const b2Vec2& normal, float32 offset, int32 vertexIndexA);


bool b2TestOverlap( const b2Shape* shapeA, int32 indexA,
     const b2Shape* shapeB, int32 indexB,
     const b2Transform& xfA, const b2Transform& xfB);



inline bool b2AABB::IsValid() const
{
 b2Vec2 d = upperBound - lowerBound;
 bool valid = d.x >= 0.0f && d.y >= 0.0f;
 valid = valid && lowerBound.IsValid() && upperBound.IsValid();
 return valid;
}

inline bool b2TestOverlap(const b2AABB& a, const b2AABB& b)
{
 b2Vec2 d1, d2;
 d1 = b.lowerBound - a.upperBound;
 d2 = a.lowerBound - b.upperBound;

 if (d1.x > 0.0f || d1.y > 0.0f)
  return false;

 if (d2.x > 0.0f || d2.y > 0.0f)
  return false;

 return true;
}
# 25 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2Shape.h" 2


struct b2MassData
{

 float32 mass;


 b2Vec2 center;


 float32 I;
};




class b2Shape
{
public:

 enum Type
 {
  e_unknown= -1,
  e_circle = 0,
  e_edge = 1,
  e_polygon = 2,
  e_loop = 3,
  e_typeCount = 4
 };

 b2Shape() { m_type = e_unknown; }
 virtual ~b2Shape() {}


 virtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;



 Type GetType() const;


 virtual int32 GetChildCount() const = 0;




 virtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;






 virtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
      const b2Transform& transform, int32 childIndex) const = 0;





 virtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;





 virtual void ComputeMass(b2MassData* massData, float32 density) const = 0;

 Type m_type;
 float32 m_radius;
};

inline b2Shape::Type b2Shape::GetType() const
{
 return m_type;
}
# 23 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.h" 2




class b2EdgeShape : public b2Shape
{
public:
 b2EdgeShape();


 void Set(const b2Vec2& v1, const b2Vec2& v2);


 b2Shape* Clone(b2BlockAllocator* allocator) const;


 int32 GetChildCount() const;


 bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;


 bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
    const b2Transform& transform, int32 childIndex) const;


 void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;


 void ComputeMass(b2MassData* massData, float32 density) const;


 b2Vec2 m_vertex1, m_vertex2;


 b2Vec2 m_vertex0, m_vertex3;
 bool m_hasVertex0, m_hasVertex3;
};

inline b2EdgeShape::b2EdgeShape()
{
 m_type = e_edge;
 m_radius = (2.0f * 0.005f);
 m_hasVertex0 = false;
 m_hasVertex3 = false;
}
# 20 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.cpp" 2
# 1 "c:/marmalade/6.0/s3e/h/std/c++/new" 1
# 21 "c:/marmalade/6.0/s3e/h/std/c++/new"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 1
# 16 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_prolog.h" 1
# 17 "c:/marmalade/6.0/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "c:/marmalade/6.0/s3e/h/std/c++/new" 2
# 38 "c:/marmalade/6.0/s3e/h/std/c++/new"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/new.h" 1
# 52 "c:/marmalade/6.0/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "c:/marmalade/6.0/s3e/h/std/c++/new" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_new.h" 1
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/exception" 1
# 58 "c:/marmalade/6.0/s3e/h/std/c++/exception"
# 1 "c:/marmalade/6.0/s3e/h/ext/../std/c++/exception.h" 1
# 18 "c:/marmalade/6.0/s3e/h/ext/../std/c++/exception.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/exception_gcc" 1
# 41 "c:/marmalade/6.0/s3e/h/std/c++/exception_gcc"
#pragma GCC visibility push(default)


extern "C++" {

namespace std
{
# 56 "c:/marmalade/6.0/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "c:/marmalade/6.0/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "c:/marmalade/6.0/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}


#pragma GCC visibility pop
# 19 "c:/marmalade/6.0/s3e/h/ext/../std/c++/exception.h" 2
# 59 "c:/marmalade/6.0/s3e/h/std/c++/exception" 2
# 75 "c:/marmalade/6.0/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "c:/marmalade/6.0/s3e/h/std/c++/exception"
}
# 12 "c:/marmalade/6.0/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "c:/marmalade/6.0/s3e/h/std/c++/stl/_new.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/new" 1
# 51 "c:/marmalade/6.0/s3e/h/std/c++/stl/_new.h" 2
# 80 "c:/marmalade/6.0/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 43 "c:/marmalade/6.0/s3e/h/std/c++/new" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h"
# 1 "c:/marmalade/6.0/s3e/h/std/c++/config/_epilog.h" 1
# 11 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "c:/marmalade/6.0/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "c:/marmalade/6.0/s3e/h/std/c++/stl/_epilog.h" 2
# 47 "c:/marmalade/6.0/s3e/h/std/c++/new" 2
# 21 "e:/users/hasan/development/marmaladeprojects/adl-stem/libraries/box2d/Box2D/Collision/Shapes/b2EdgeShape.cpp" 2
using namespace _STL;

void b2EdgeShape::Set(const b2Vec2& v1, const b2Vec2& v2)
{
 m_vertex1 = v1;
 m_vertex2 = v2;
 m_hasVertex0 = false;
 m_hasVertex3 = false;
}

b2Shape* b2EdgeShape::Clone(b2BlockAllocator* allocator) const
{
 void* mem = allocator->Allocate(sizeof(b2EdgeShape));
 b2EdgeShape* clone = new (mem) b2EdgeShape;
 *clone = *this;
 return clone;
}

int32 b2EdgeShape::GetChildCount() const
{
 return 1;
}

bool b2EdgeShape::TestPoint(const b2Transform& xf, const b2Vec2& p) const
{
 ((void)(xf));
 ((void)(p));
 return false;
}





bool b2EdgeShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
       const b2Transform& xf, int32 childIndex) const
{
 ((void)(childIndex));


 b2Vec2 p1 = b2MulT(xf.q, input.p1 - xf.p);
 b2Vec2 p2 = b2MulT(xf.q, input.p2 - xf.p);
 b2Vec2 d = p2 - p1;

 b2Vec2 v1 = m_vertex1;
 b2Vec2 v2 = m_vertex2;
 b2Vec2 e = v2 - v1;
 b2Vec2 normal(e.y, -e.x);
 normal.Normalize();




 float32 numerator = b2Dot(normal, v1 - p1);
 float32 denominator = b2Dot(normal, d);

 if (denominator == 0.0f)
 {
  return false;
 }

 float32 t = numerator / denominator;
 if (t < 0.0f || 1.0f < t)
 {
  return false;
 }

 b2Vec2 q = p1 + t * d;



 b2Vec2 r = v2 - v1;
 float32 rr = b2Dot(r, r);
 if (rr == 0.0f)
 {
  return false;
 }

 float32 s = b2Dot(q - v1, r) / rr;
 if (s < 0.0f || 1.0f < s)
 {
  return false;
 }

 output->fraction = t;
 if (numerator > 0.0f)
 {
  output->normal = -normal;
 }
 else
 {
  output->normal = normal;
 }
 return true;
}

void b2EdgeShape::ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const
{
 ((void)(childIndex));

 b2Vec2 v1 = b2Mul(xf, m_vertex1);
 b2Vec2 v2 = b2Mul(xf, m_vertex2);

 b2Vec2 lower = b2Min(v1, v2);
 b2Vec2 upper = b2Max(v1, v2);

 b2Vec2 r(m_radius, m_radius);
 aabb->lowerBound = lower - r;
 aabb->upperBound = upper + r;
}

void b2EdgeShape::ComputeMass(b2MassData* massData, float32 density) const
{
 ((void)(density));

 massData->mass = 0.0f;
 massData->center = 0.5f * (m_vertex1 + m_vertex2);
 massData->I = 0.0f;
}
